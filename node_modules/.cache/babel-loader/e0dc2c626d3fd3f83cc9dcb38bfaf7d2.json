{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _declaration = _interopRequireDefault(require(\"./declaration\"));\n\nvar _comment = _interopRequireDefault(require(\"./comment\"));\n\nvar _node = _interopRequireDefault(require(\"./node\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction cleanSource(nodes) {\n  return nodes.map(function (i) {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\n\n\nvar Container = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(Container, _Node);\n\n  function Container() {\n    return _Node.apply(this, arguments) || this;\n  }\n\n  var _proto = Container.prototype;\n\n  _proto.push = function push(child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  }\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }')\n   * const rule = root.first\n   *\n   * for (const decl of rule.nodes) {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Cycle will be infinite, because cloneBefore moves the current node\n   *   // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Will be executed only for color and z-index\n   * })\n   */\n  ;\n\n  _proto.each = function each(callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n    if (!this.nodes) return undefined;\n    var index, result;\n\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n    return result;\n  }\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * })\n   */\n  ;\n\n  _proto.walk = function walk(callback) {\n    return this.each(function (child, i) {\n      var result;\n\n      try {\n        result = callback(child, i);\n      } catch (e) {\n        e.postcssNode = child;\n\n        if (e.stack && child.source && /\\n\\s{4}at /.test(e.stack)) {\n          var s = child.source;\n          e.stack = e.stack.replace(/\\n\\s{4}at /, \"$&\" + s.input.from + \":\" + s.start.line + \":\" + s.start.column + \"$&\");\n        }\n\n        throw e;\n      }\n\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   String or regular expression\n   *                                 to filter declarations by property name.\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop)\n   * })\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove()\n   * })\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value)\n   * })\n   */\n  ;\n\n  _proto.walkDecls = function walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop;\n      return this.walk(function (child, i) {\n        if (child.type === 'decl') {\n          return callback(child, i);\n        }\n      });\n    }\n\n    if (prop instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i);\n        }\n      });\n    }\n\n    return this.walk(function (child, i) {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i);\n      }\n    });\n  }\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] String or regular expression\n   *                                   to filter rules by selector.\n   * @param {childIterator} callback   Iterator receives each node and index.\n   *\n   * @return {false|undefined} returns `false` if iteration was broke.\n   *\n   * @example\n   * const selectors = []\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector)\n   * })\n   * console.log(`Your CSS uses ${ selectors.length } selectors`)\n   */\n  ;\n\n  _proto.walkRules = function walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector;\n      return this.walk(function (child, i) {\n        if (child.type === 'rule') {\n          return callback(child, i);\n        }\n      });\n    }\n\n    if (selector instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i);\n        }\n      });\n    }\n\n    return this.walk(function (child, i) {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i);\n      }\n    });\n  }\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   String or regular expression\n   *                                 to filter at-rules by name.\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if (isOld(rule.name)) rule.remove()\n   * })\n   *\n   * let first = false\n   * root.walkAtRules('charset', rule => {\n   *   if (!first) {\n   *     first = true\n   *   } else {\n   *     rule.remove()\n   *   }\n   * })\n   */\n  ;\n\n  _proto.walkAtRules = function walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name;\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule') {\n          return callback(child, i);\n        }\n      });\n    }\n\n    if (name instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i);\n        }\n      });\n    }\n\n    return this.walk(function (child, i) {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i);\n      }\n    });\n  }\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove()\n   * })\n   */\n  ;\n\n  _proto.walkComments = function walkComments(callback) {\n    return this.walk(function (child, i) {\n      if (child.type === 'comment') {\n        return callback(child, i);\n      }\n    });\n  }\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children New nodes.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n   * rule.append(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   */\n  ;\n\n  _proto.append = function append() {\n    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n\n    for (var _i = 0, _children = children; _i < _children.length; _i++) {\n      var child = _children[_i];\n      var nodes = this.normalize(child, this.last);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {\n        var node = _step.value;\n        this.nodes.push(node);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children New nodes.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n   * rule.prepend(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   */\n  ;\n\n  _proto.prepend = function prepend() {\n    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      children[_key2] = arguments[_key2];\n    }\n\n    children = children.reverse();\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {\n      var child = _step2.value;\n      var nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(nodes), _step3; !(_step3 = _iterator3()).done;) {\n        var node = _step3.value;\n        this.nodes.unshift(node);\n      }\n\n      for (var id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length;\n      }\n    }\n\n    return this;\n  };\n\n  _proto.cleanRaws = function cleanRaws(keepBetween) {\n    _Node.prototype.cleanRaws.call(this, keepBetween);\n\n    if (this.nodes) {\n      for (var _iterator4 = _createForOfIteratorHelperLoose(this.nodes), _step4; !(_step4 = _iterator4()).done;) {\n        var node = _step4.value;\n        node.cleanRaws(keepBetween);\n      }\n    }\n  }\n  /**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             Child or child’s index.\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))\n   */\n  ;\n\n  _proto.insertBefore = function insertBefore(exist, add) {\n    exist = this.index(exist);\n    var type = exist === 0 ? 'prepend' : false;\n    var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n\n    for (var _iterator5 = _createForOfIteratorHelperLoose(nodes), _step5; !(_step5 = _iterator5()).done;) {\n      var node = _step5.value;\n      this.nodes.splice(exist, 0, node);\n    }\n\n    var index;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             Child or child’s index.\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   */\n  ;\n\n  _proto.insertAfter = function insertAfter(exist, add) {\n    exist = this.index(exist);\n    var nodes = this.normalize(add, this.nodes[exist]).reverse();\n\n    for (var _iterator6 = _createForOfIteratorHelperLoose(nodes), _step6; !(_step6 = _iterator6()).done;) {\n      var node = _step6.value;\n      this.nodes.splice(exist + 1, 0, node);\n    }\n\n    var index;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child Child or child’s index.\n   *\n   * @return {Node} This node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl)\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */\n  ;\n\n  _proto.removeChild = function removeChild(child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n    var index;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * rule.removeAll()\n   * rule.nodes.length //=> 0\n   */\n  ;\n\n  _proto.removeAll = function removeAll() {\n    for (var _iterator7 = _createForOfIteratorHelperLoose(this.nodes), _step7; !(_step7 = _iterator7()).done;) {\n      var node = _step7.value;\n      node.parent = undefined;\n    }\n\n    this.nodes = [];\n    return this;\n  }\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      Replace pattern.\n   * @param {object} opts                Options to speed up the search.\n   * @param {string|string[]} opts.props An array of property names.\n   * @param {string} opts.fast           String that’s used to narrow down\n   *                                     values and speed up the regexp search.\n   * @param {function|string} callback   String to replace pattern or callback\n   *                                     that returns a new value. The callback\n   *                                     will receive the same arguments\n   *                                     as those passed to a function parameter\n   *                                     of `String#replace`.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px'\n   * })\n   */\n  ;\n\n  _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts;\n      opts = {};\n    }\n\n    this.walkDecls(function (decl) {\n      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n      decl.value = decl.value.replace(pattern, callback);\n    });\n    return this;\n  }\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * @param {childCondition} condition Iterator returns true or false.\n   *\n   * @return {boolean} Is every child pass condition.\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-')\n   */\n  ;\n\n  _proto.every = function every(condition) {\n    return this.nodes.every(condition);\n  }\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * @param {childCondition} condition Iterator returns true or false.\n   *\n   * @return {boolean} Is some child pass condition.\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-')\n   */\n  ;\n\n  _proto.some = function some(condition) {\n    return this.nodes.some(condition);\n  }\n  /**\n   * Returns a `child`’s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child Child of the current container.\n   *\n   * @return {number} Child index.\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */\n  ;\n\n  _proto.index = function index(child) {\n    if (typeof child === 'number') {\n      return child;\n    }\n\n    return this.nodes.indexOf(child);\n  }\n  /**\n   * The container’s first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first === rules.nodes[0]\n   */\n  ;\n\n  _proto.normalize = function normalize(nodes, sample) {\n    var _this = this;\n\n    if (typeof nodes === 'string') {\n      var parse = require('./parse');\n\n      nodes = cleanSource(parse(nodes).nodes);\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0);\n\n      for (var _iterator8 = _createForOfIteratorHelperLoose(nodes), _step8; !(_step8 = _iterator8()).done;) {\n        var i = _step8.value;\n        if (i.parent) i.parent.removeChild(i, 'ignore');\n      }\n    } else if (nodes.type === 'root') {\n      nodes = nodes.nodes.slice(0);\n\n      for (var _iterator9 = _createForOfIteratorHelperLoose(nodes), _step9; !(_step9 = _iterator9()).done;) {\n        var _i2 = _step9.value;\n        if (_i2.parent) _i2.parent.removeChild(_i2, 'ignore');\n      }\n    } else if (nodes.type) {\n      nodes = [nodes];\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation');\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value);\n      }\n\n      nodes = [new _declaration.default(nodes)];\n    } else if (nodes.selector) {\n      var Rule = require('./rule');\n\n      nodes = [new Rule(nodes)];\n    } else if (nodes.name) {\n      var AtRule = require('./at-rule');\n\n      nodes = [new AtRule(nodes)];\n    } else if (nodes.text) {\n      nodes = [new _comment.default(nodes)];\n    } else {\n      throw new Error('Unknown node type in node creation');\n    }\n\n    var processed = nodes.map(function (i) {\n      if (i.parent) i.parent.removeChild(i);\n\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n        }\n      }\n\n      i.parent = _this;\n      return i;\n    });\n    return processed;\n  }\n  /**\n   * @memberof Container#\n   * @member {Node[]} nodes An array containing the container’s children.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }')\n   * root.nodes.length           //=> 1\n   * root.nodes[0].selector      //=> 'a'\n   * root.nodes[0].nodes[0].prop //=> 'color'\n   */\n  ;\n\n  _createClass(Container, [{\n    key: \"first\",\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[0];\n    }\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last === rule.nodes[rule.nodes.length - 1]\n     */\n\n  }, {\n    key: \"last\",\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[this.nodes.length - 1];\n    }\n  }]);\n\n  return Container;\n}(_node.default);\n\nvar _default = Container;\n/**\n * @callback childCondition\n * @param {Node} node    Container child.\n * @param {number} index Child index.\n * @param {Node[]} nodes All container children.\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    Container child.\n * @param {number} index Child index.\n * @return {false|undefined} Returning `false` will break iteration.\n */\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["container.es6"],"names":["i","cleanSource","Container","Node","push","child","each","id","index","result","callback","walk","e","s","walkDecls","prop","walkRules","selector","walkAtRules","name","walkComments","append","children","nodes","node","prepend","cleanRaws","insertBefore","exist","type","insertAfter","removeChild","removeAll","replaceValues","opts","decl","every","some","normalize","parse","require","Array","String","Declaration","Rule","AtRule","Comment","processed","sample"],"mappings":"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","sourcesContent":["import Declaration from './declaration'\nimport Comment from './comment'\nimport Node from './node'\n\nfunction cleanSource (nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\nclass Container extends Node {\n  push (child) {\n    child.parent = this\n    this.nodes.push(child)\n    return this\n  }\n\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }')\n   * const rule = root.first\n   *\n   * for (const decl of rule.nodes) {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Cycle will be infinite, because cloneBefore moves the current node\n   *   // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Will be executed only for color and z-index\n   * })\n   */\n  each (callback) {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = { }\n\n    this.lastEach += 1\n    let id = this.lastEach\n    this.indexes[id] = 0\n\n    if (!this.nodes) return undefined\n\n    let index, result\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id]\n      result = callback(this.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[id] += 1\n    }\n\n    delete this.indexes[id]\n\n    return result\n  }\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * })\n   */\n  walk (callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        e.postcssNode = child\n        if (e.stack && child.source && /\\n\\s{4}at /.test(e.stack)) {\n          let s = child.source\n          e.stack = e.stack.replace(/\\n\\s{4}at /,\n            `$&${ s.input.from }:${ s.start.line }:${ s.start.column }$&`)\n        }\n        throw e\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n      return result\n    })\n  }\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   String or regular expression\n   *                                 to filter declarations by property name.\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop)\n   * })\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove()\n   * })\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value)\n   * })\n   */\n  walkDecls (prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] String or regular expression\n   *                                   to filter rules by selector.\n   * @param {childIterator} callback   Iterator receives each node and index.\n   *\n   * @return {false|undefined} returns `false` if iteration was broke.\n   *\n   * @example\n   * const selectors = []\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector)\n   * })\n   * console.log(`Your CSS uses ${ selectors.length } selectors`)\n   */\n  walkRules (selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   String or regular expression\n   *                                 to filter at-rules by name.\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if (isOld(rule.name)) rule.remove()\n   * })\n   *\n   * let first = false\n   * root.walkAtRules('charset', rule => {\n   *   if (!first) {\n   *     first = true\n   *   } else {\n   *     rule.remove()\n   *   }\n   * })\n   */\n  walkAtRules (name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback Iterator receives each node and index.\n   *\n   * @return {false|undefined} Returns `false` if iteration was broke.\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove()\n   * })\n   */\n  walkComments (callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children New nodes.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n   * rule.append(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   */\n  append (...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.nodes.push(node)\n    }\n    return this\n  }\n\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children New nodes.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n   * rule.prepend(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   */\n  prepend (...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n    return this\n  }\n\n  cleanRaws (keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  /**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             Child or child’s index.\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))\n   */\n  insertBefore (exist, add) {\n    exist = this.index(exist)\n\n    let type = exist === 0 ? 'prepend' : false\n    let nodes = this.normalize(add, this.nodes[exist], type).reverse()\n    for (let node of nodes) this.nodes.splice(exist, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             Child or child’s index.\n   * @param {Node|object|string|Node[]} add New node.\n   *\n   * @return {Node} This node for methods chain.\n   */\n  insertAfter (exist, add) {\n    exist = this.index(exist)\n\n    let nodes = this.normalize(add, this.nodes[exist]).reverse()\n    for (let node of nodes) this.nodes.splice(exist + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child Child or child’s index.\n   *\n   * @return {Node} This node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl)\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */\n  removeChild (child) {\n    child = this.index(child)\n    this.nodes[child].parent = undefined\n    this.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * rule.removeAll()\n   * rule.nodes.length //=> 0\n   */\n  removeAll () {\n    for (let node of this.nodes) node.parent = undefined\n    this.nodes = []\n    return this\n  }\n\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      Replace pattern.\n   * @param {object} opts                Options to speed up the search.\n   * @param {string|string[]} opts.props An array of property names.\n   * @param {string} opts.fast           String that’s used to narrow down\n   *                                     values and speed up the regexp search.\n   * @param {function|string} callback   String to replace pattern or callback\n   *                                     that returns a new value. The callback\n   *                                     will receive the same arguments\n   *                                     as those passed to a function parameter\n   *                                     of `String#replace`.\n   *\n   * @return {Node} This node for methods chain.\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px'\n   * })\n   */\n  replaceValues (pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = { }\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && opts.props.indexOf(decl.prop) === -1) return\n      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    return this\n  }\n\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * @param {childCondition} condition Iterator returns true or false.\n   *\n   * @return {boolean} Is every child pass condition.\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-')\n   */\n  every (condition) {\n    return this.nodes.every(condition)\n  }\n\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * @param {childCondition} condition Iterator returns true or false.\n   *\n   * @return {boolean} Is some child pass condition.\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-')\n   */\n  some (condition) {\n    return this.nodes.some(condition)\n  }\n\n  /**\n   * Returns a `child`’s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child Child of the current container.\n   *\n   * @return {number} Child index.\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */\n  index (child) {\n    if (typeof child === 'number') {\n      return child\n    }\n    return this.nodes.indexOf(child)\n  }\n\n  /**\n   * The container’s first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first === rules.nodes[0]\n   */\n  get first () {\n    if (!this.nodes) return undefined\n    return this.nodes[0]\n  }\n\n  /**\n   * The container’s last child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.last === rule.nodes[rule.nodes.length - 1]\n   */\n  get last () {\n    if (!this.nodes) return undefined\n    return this.nodes[this.nodes.length - 1]\n  }\n\n  normalize (nodes, sample) {\n    if (typeof nodes === 'string') {\n      let parse = require('./parse')\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector) {\n      let Rule = require('./rule')\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      let AtRule = require('./at-rule')\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      if (i.parent) i.parent.removeChild(i)\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/[^\\s]/g, '')\n        }\n      }\n      i.parent = this\n      return i\n    })\n\n    return processed\n  }\n\n  /**\n   * @memberof Container#\n   * @member {Node[]} nodes An array containing the container’s children.\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }')\n   * root.nodes.length           //=> 1\n   * root.nodes[0].selector      //=> 'a'\n   * root.nodes[0].nodes[0].prop //=> 'color'\n   */\n}\n\nexport default Container\n\n/**\n * @callback childCondition\n * @param {Node} node    Container child.\n * @param {number} index Child index.\n * @param {Node[]} nodes All container children.\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    Container child.\n * @param {number} index Child index.\n * @return {false|undefined} Returning `false` will break iteration.\n */\n"]},"metadata":{},"sourceType":"script"}