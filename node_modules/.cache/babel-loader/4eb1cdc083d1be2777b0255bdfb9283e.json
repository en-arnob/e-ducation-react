{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _declaration = _interopRequireDefault(require(\"./declaration\"));\n\nvar _tokenize = _interopRequireDefault(require(\"./tokenize\"));\n\nvar _comment = _interopRequireDefault(require(\"./comment\"));\n\nvar _atRule = _interopRequireDefault(require(\"./at-rule\"));\n\nvar _root = _interopRequireDefault(require(\"./root\"));\n\nvar _rule = _interopRequireDefault(require(\"./rule\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(input) {\n    this.input = input;\n    this.root = new _root.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto.createTokenizer = function createTokenizer() {\n    this.tokenizer = (0, _tokenize.default)(this.input);\n  };\n\n  _proto.parse = function parse() {\n    var token;\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n\n        case ';':\n          this.freeSemicolon(token);\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other(token);\n          break;\n      }\n    }\n\n    this.endFile();\n  };\n\n  _proto.comment = function comment(token) {\n    var node = new _comment.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  _proto.emptyRule = function emptyRule(token) {\n    var node = new _rule.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n\n  _proto.other = function other(start) {\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var tokens = [];\n    var token = start;\n\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      token = this.tokenizer.nextToken();\n    }\n\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.tokenizer.back(tokens.pop());\n      }\n\n      this.decl(tokens);\n    } else {\n      this.unknownWord(tokens);\n    }\n  };\n\n  _proto.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n\n  _proto.decl = function decl(tokens) {\n    var node = new _declaration.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n\n    while (tokens.length) {\n      var type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    var token;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n\n  _proto.atrule = function atrule(token) {\n    var node = new _atRule.default();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2], token[3]);\n    var prev;\n    var shift;\n    var last = false;\n    var open = false;\n    var params = [];\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1;\n          prev = params[shift];\n\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift];\n          }\n\n          if (prev) {\n            node.source.end = {\n              line: prev[4],\n              column: prev[5]\n            };\n          }\n        }\n\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n\n  _proto.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n\n  _proto.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  };\n\n  _proto.freeSemicolon = function freeSemicolon(token) {\n    this.spaces += token[1];\n\n    if (this.current.nodes) {\n      var prev = this.current.nodes[this.current.nodes.length - 1];\n\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  } // Helpers\n  ;\n\n  _proto.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n\n  _proto.raw = function raw(node, prop, tokens) {\n    var token, type;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n    var next, prev;\n    var pattern = /^([.|#])?([\\w])+/i;\n\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1];\n        next = tokens[i + 1];\n\n        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n          value += token[1];\n        } else {\n          clean = false;\n        }\n\n        continue;\n      }\n\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n\n    node[prop] = value;\n  };\n\n  _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next;\n    var spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  };\n\n  _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  _proto.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n\n  _proto.colon = function colon(tokens) {\n    var brackets = 0;\n    var token, type, prev;\n\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      }\n\n      if (type === ')') {\n        brackets -= 1;\n      }\n\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  } // Errors\n  ;\n\n  _proto.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n\n  _proto.unknownWord = function unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n  };\n\n  _proto.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n\n  _proto.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n\n  _proto.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n\n  _proto.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n\n  _proto.precheckMissedSemicolon = function precheckMissedSemicolon()\n  /* tokens */\n  {// Hook for Safe Parser\n  };\n\n  _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token;\n\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports.default;","map":{"version":3,"sources":["parser.es6"],"names":["Parser","Root","input","start","line","column","createTokenizer","parse","token","comment","node","Comment","text","match","emptyRule","Rule","other","end","type","colon","bracket","brackets","tokens","rule","decl","Declaration","last","i","string","cache","str","j","atrule","AtRule","open","params","shift","prev","endFile","freeSemicolon","init","raw","length","value","clean","pattern","next","all","spacesAndCommentsFromEnd","spaces","lastTokenType","spacesAndCommentsFromStart","spacesFromEnd","stringFrom","result","unclosedBracket","unknownWord","unexpectedClose","unclosedBlock","pos","doubleColon","unnamedAtrule","precheckMissedSemicolon","checkMissedSemicolon","founded"],"mappings":"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","sourcesContent":["import Declaration from './declaration'\nimport tokenizer from './tokenize'\nimport Comment from './comment'\nimport AtRule from './at-rule'\nimport Root from './root'\nimport Rule from './rule'\n\nexport default class Parser {\n  constructor (input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { line: 1, column: 1 } }\n  }\n\n  createTokenizer () {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse () {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment (token) {\n    let node = new Comment()\n    this.init(node, token[2], token[3])\n    node.source.end = { line: token[4], column: token[5] }\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule (token) {\n    let node = new Rule()\n    this.init(node, token[2], token[3])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other (start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0]\n        if (token !== 'space' && token !== 'comment') break\n        this.tokenizer.back(tokens.pop())\n      }\n      this.decl(tokens)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule (tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2], tokens[0][3])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl (tokens) {\n    let node = new Declaration()\n    this.init(node)\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n    if (last[4]) {\n      node.source.end = { line: last[4], column: last[5] }\n    } else {\n      node.source.end = { line: last[2], column: last[3] }\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = { line: tokens[0][2], column: tokens[0][3] }\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n    node.raws.between += this.spacesAndCommentsFromStart(tokens)\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    this.raw(node, 'value', tokens)\n\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens)\n  }\n\n  atrule (token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2], token[3])\n\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      if (token[0] === ';') {\n        node.source.end = { line: token[2], column: token[3] }\n        this.semicolon = true\n        break\n      } else if (token[0] === '{') {\n        open = true\n        break\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1\n          prev = params[shift]\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift]\n          }\n          if (prev) {\n            node.source.end = { line: prev[4], column: prev[5] }\n          }\n        }\n        this.end(token)\n        break\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = { line: token[4], column: token[5] }\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end (token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = { line: token[2], column: token[3] }\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile () {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon (token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  init (node, line, column) {\n    this.current.push(node)\n\n    node.source = { start: { line, column }, input: this.input }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw (node, prop, tokens) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n    let pattern = /^([.|#])?([\\w])+/i\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1]\n        next = tokens[i + 1]\n\n        if (\n          prev[0] !== 'space' &&\n          next[0] !== 'space' &&\n          pattern.test(prev[1]) &&\n          pattern.test(next[1])\n        ) {\n          value += token[1]\n        } else {\n          clean = false\n        }\n\n        continue\n      }\n\n      if (type === 'comment' || (type === 'space' && i === length - 1)) {\n        clean = false\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd (tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart (tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd (tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom (tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon (tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let i = 0; i < tokens.length; i++) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket (bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3])\n  }\n\n  unknownWord (tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3])\n  }\n\n  unexpectedClose (token) {\n    throw this.input.error('Unexpected }', token[2], token[3])\n  }\n\n  unclosedBlock () {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon (token) {\n    throw this.input.error('Double colon', token[2], token[3])\n  }\n\n  unnamedAtrule (node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3])\n  }\n\n  precheckMissedSemicolon (/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon (tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    throw this.input.error('Missed semicolon', token[2], token[3])\n  }\n}\n"]},"metadata":{},"sourceType":"script"}