{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _mapGenerator = _interopRequireDefault(require(\"./map-generator\"));\n\nvar _stringify2 = _interopRequireDefault(require(\"./stringify\"));\n\nvar _warnOnce = _interopRequireDefault(require(\"./warn-once\"));\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function';\n}\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */\n\n\nvar LazyResult = /*#__PURE__*/function () {\n  function LazyResult(processor, css, opts) {\n    this.stringified = false;\n    this.processed = false;\n    var root;\n\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result.default) {\n      root = css.root;\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n\n    this.result = new _result.default(processor, root, opts);\n  }\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */\n\n\n  var _proto = LazyResult.prototype;\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */\n\n  _proto.warnings = function warnings() {\n    return this.sync().warnings();\n  }\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */\n  ;\n\n  _proto.toString = function toString() {\n    return this.css;\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */\n  ;\n\n  _proto.then = function then(onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected);\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */\n  ;\n\n  _proto.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */\n  ;\n\n  _proto.finally = function _finally(onFinally) {\n    return this.async().then(onFinally, onFinally);\n  };\n\n  _proto.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          var pluginName = plugin.postcssPlugin;\n          var pluginVer = plugin.postcssVersion;\n          var runtimeVer = this.result.processor.version;\n          var a = pluginVer.split('.');\n          var b = runtimeVer.split('.');\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n          }\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n\n  _proto.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n\n  _proto.async = function async() {\n    var _this2 = this;\n\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n\n    if (this.processing) {\n      return this.processing;\n    }\n\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n\n  _proto.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n\n    if (this.error) throw this.error;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(this.result.processor.plugins), _step; !(_step = _iterator()).done;) {\n      var plugin = _step.value;\n      var promise = this.run(plugin);\n\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n\n    return this.result;\n  };\n\n  _proto.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n\n  _proto.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify2.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n\n  _createClass(LazyResult, [{\n    key: \"processor\",\n    get: function get() {\n      return this.result.processor;\n    }\n    /**\n     * Options from the {@link Processor#process} call.\n     *\n     * @type {processOptions}\n     */\n\n  }, {\n    key: \"opts\",\n    get: function get() {\n      return this.result.opts;\n    }\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n\n  }, {\n    key: \"css\",\n    get: function get() {\n      return this.stringify().css;\n    }\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n\n  }, {\n    key: \"content\",\n    get: function get() {\n      return this.stringify().content;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n\n  }, {\n    key: \"map\",\n    get: function get() {\n      return this.stringify().map;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this.sync().root;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n\n  }, {\n    key: \"messages\",\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n\n  return LazyResult;\n}();\n\nvar _default = LazyResult;\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["lazy-result.es6"],"names":["obj","LazyResult","css","root","Result","opts","parser","parse","warnings","toString","then","process","catch","finally","handleError","error","plugin","pluginName","pluginVer","runtimeVer","a","b","parseInt","console","asyncTick","resolve","promise","isPromise","reject","async","sync","run","stringify","str","map","MapGenerator","data"],"mappings":"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","sourcesContent":["import MapGenerator from './map-generator'\nimport stringify from './stringify'\nimport warnOnce from './warn-once'\nimport Result from './result'\nimport parse from './parse'\n\nfunction isPromise (obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */\nclass LazyResult {\n  constructor (processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = css\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = css.root\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = { }\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.error = error\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n  }\n\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */\n  get processor () {\n    return this.result.processor\n  }\n\n  /**\n   * Options from the {@link Processor#process} call.\n   *\n   * @type {processOptions}\n   */\n  get opts () {\n    return this.result.opts\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins, converts `Root`\n   * to a CSS string and returns {@link Result#css}.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {string}\n   * @see Result#css\n   */\n  get css () {\n    return this.stringify().css\n  }\n\n  /**\n   * An alias for the `css` property. Use it with syntaxes\n   * that generate non-CSS output.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {string}\n   * @see Result#content\n   */\n  get content () {\n    return this.stringify().content\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#map}.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {SourceMapGenerator}\n   * @see Result#map\n   */\n  get map () {\n    return this.stringify().map\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#root}.\n   *\n   * This property will only work with synchronous plugins. If the processor\n   * contains any asynchronous plugins it will throw an error.\n   *\n   * This is why this method is only for debug purpose,\n   * you should always use {@link LazyResult#then}.\n   *\n   * @type {Root}\n   * @see Result#root\n   */\n  get root () {\n    return this.sync().root\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#messages}.\n   *\n   * This property will only work with synchronous plugins. If the processor\n   * contains any asynchronous plugins it will throw an error.\n   *\n   * This is why this method is only for debug purpose,\n   * you should always use {@link LazyResult#then}.\n   *\n   * @type {Message[]}\n   * @see Result#messages\n   */\n  get messages () {\n    return this.sync().messages\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */\n  warnings () {\n    return this.sync().warnings()\n  }\n\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */\n  toString () {\n    return this.css\n  }\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */\n  then (onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n          'and will not find Browserslist config. Set it to CSS file path ' +\n          'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */\n  catch (onRejected) {\n    return this.async().catch(onRejected)\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */\n  finally (onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  handleError (error, plugin) {\n    try {\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n              'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' +\n              pluginVer + '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err)\n    }\n  }\n\n  asyncTick (resolve, reject) {\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true\n      return resolve()\n    }\n\n    try {\n      let plugin = this.processor.plugins[this.plugin]\n      let promise = this.run(plugin)\n      this.plugin += 1\n\n      if (isPromise(promise)) {\n        promise.then(() => {\n          this.asyncTick(resolve, reject)\n        }).catch(error => {\n          this.handleError(error, plugin)\n          this.processed = true\n          reject(error)\n        })\n      } else {\n        this.asyncTick(resolve, reject)\n      }\n    } catch (error) {\n      this.processed = true\n      reject(error)\n    }\n  }\n\n  async () {\n    if (this.processed) {\n      return new Promise((resolve, reject) => {\n        if (this.error) {\n          reject(this.error)\n        } else {\n          resolve(this.stringify())\n        }\n      })\n    }\n    if (this.processing) {\n      return this.processing\n    }\n\n    this.processing = new Promise((resolve, reject) => {\n      if (this.error) return reject(this.error)\n      this.plugin = 0\n      this.asyncTick(resolve, reject)\n    }).then(() => {\n      this.processed = true\n      return this.stringify()\n    })\n\n    return this.processing\n  }\n\n  sync () {\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw new Error(\n        'Use process(css).then(cb) to work with async plugins')\n    }\n\n    if (this.error) throw this.error\n\n    for (let plugin of this.result.processor.plugins) {\n      let promise = this.run(plugin)\n      if (isPromise(promise)) {\n        throw new Error(\n          'Use process(css).then(cb) to work with async plugins')\n      }\n    }\n\n    return this.result\n  }\n\n  run (plugin) {\n    this.result.lastPlugin = plugin\n\n    try {\n      return plugin(this.result.root, this.result)\n    } catch (error) {\n      this.handleError(error, plugin)\n      throw error\n    }\n  }\n\n  stringify () {\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n}\n\nexport default LazyResult\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"]},"metadata":{},"sourceType":"script"}