{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = tokenizer;\nvar SINGLE_QUOTE = '\\''.charCodeAt(0);\nvar DOUBLE_QUOTE = '\"'.charCodeAt(0);\nvar BACKSLASH = '\\\\'.charCodeAt(0);\nvar SLASH = '/'.charCodeAt(0);\nvar NEWLINE = '\\n'.charCodeAt(0);\nvar SPACE = ' '.charCodeAt(0);\nvar FEED = '\\f'.charCodeAt(0);\nvar TAB = '\\t'.charCodeAt(0);\nvar CR = '\\r'.charCodeAt(0);\nvar OPEN_SQUARE = '['.charCodeAt(0);\nvar CLOSE_SQUARE = ']'.charCodeAt(0);\nvar OPEN_PARENTHESES = '('.charCodeAt(0);\nvar CLOSE_PARENTHESES = ')'.charCodeAt(0);\nvar OPEN_CURLY = '{'.charCodeAt(0);\nvar CLOSE_CURLY = '}'.charCodeAt(0);\nvar SEMICOLON = ';'.charCodeAt(0);\nvar ASTERISK = '*'.charCodeAt(0);\nvar COLON = ':'.charCodeAt(0);\nvar AT = '@'.charCodeAt(0);\nvar RE_AT_END = /[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g;\nvar RE_WORD_END = /[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\\\/(\"'\\n]/;\nvar RE_HEX_ESCAPE = /[a-f0-9]/i;\n\nfunction tokenizer(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var css = input.css.valueOf();\n  var ignore = options.ignoreErrors;\n  var code, next, quote, lines, last, content, escape;\n  var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;\n  var length = css.length;\n  var offset = -1;\n  var line = 1;\n  var pos = 0;\n  var buffer = [];\n  var returned = [];\n\n  function position() {\n    return pos;\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, line, pos - offset);\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length;\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop();\n    if (pos >= length) return;\n    var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n    code = css.charCodeAt(pos);\n\n    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === NEWLINE) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        currentToken = ['space', css.slice(pos, next)];\n        pos = next - 1;\n        break;\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES:\n        var controlChar = String.fromCharCode(code);\n        currentToken = [controlChar, controlChar, line, pos - offset];\n        break;\n\n      case OPEN_PARENTHESES:\n        prev = buffer.length ? buffer.pop()[1] : '';\n        n = css.charCodeAt(pos + 1);\n\n        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n          next = pos;\n\n          do {\n            escaped = false;\n            next = css.indexOf(')', next + 1);\n\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos;\n                break;\n              } else {\n                unclosed('bracket');\n              }\n            }\n\n            escapePos = next;\n\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1;\n              escaped = !escaped;\n            }\n          } while (escaped);\n\n          currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n          pos = next;\n        } else {\n          next = css.indexOf(')', pos + 1);\n          content = css.slice(pos, next + 1);\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', line, pos - offset];\n          } else {\n            currentToken = ['brackets', content, line, pos - offset, line, next - offset];\n            pos = next;\n          }\n        }\n\n        break;\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1;\n              break;\n            } else {\n              unclosed('string');\n            }\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        content = css.slice(pos, next + 1);\n        lines = content.split('\\n');\n        last = lines.length - 1;\n\n        if (last > 0) {\n          nextLine = line + last;\n          nextOffset = next - lines[last].length;\n        } else {\n          nextLine = line;\n          nextOffset = offset;\n        }\n\n        currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];\n        offset = nextOffset;\n        line = nextLine;\n        pos = next;\n        break;\n\n      case AT:\n        RE_AT_END.lastIndex = pos + 1;\n        RE_AT_END.test(css);\n\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = RE_AT_END.lastIndex - 2;\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n        pos = next;\n        break;\n\n      case BACKSLASH:\n        next = pos;\n        escape = true;\n\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1;\n          escape = !escape;\n        }\n\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n          next += 1;\n\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1;\n            }\n\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1;\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n        pos = next;\n        break;\n\n      default:\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1;\n\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length;\n            } else {\n              unclosed('comment');\n            }\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else {\n          RE_WORD_END.lastIndex = pos + 1;\n          RE_WORD_END.test(css);\n\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = RE_WORD_END.lastIndex - 2;\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n          buffer.push(currentToken);\n          pos = next;\n        }\n\n        break;\n    }\n\n    pos++;\n    return currentToken;\n  }\n\n  function back(token) {\n    returned.push(token);\n  }\n\n  return {\n    back: back,\n    nextToken: nextToken,\n    endOfFile: endOfFile,\n    position: position\n  };\n}\n\nmodule.exports = exports.default;","map":{"version":3,"sources":["tokenize.es6"],"names":["SINGLE_QUOTE","DOUBLE_QUOTE","BACKSLASH","SLASH","NEWLINE","SPACE","FEED","TAB","CR","OPEN_SQUARE","CLOSE_SQUARE","OPEN_PARENTHESES","CLOSE_PARENTHESES","OPEN_CURLY","CLOSE_CURLY","SEMICOLON","ASTERISK","COLON","AT","RE_AT_END","RE_WORD_END","RE_BAD_BRACKET","RE_HEX_ESCAPE","options","css","input","ignore","length","offset","line","pos","buffer","returned","ignoreUnclosed","opts","code","next","currentToken","controlChar","String","prev","n","escaped","unclosed","escapePos","content","quote","lines","last","nextLine","nextOffset","escape","back","nextToken","endOfFile","position"],"mappings":"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","sourcesContent":["const SINGLE_QUOTE = '\\''.charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g\nconst RE_WORD_END = /[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\\\/(\"'\\n]/\nconst RE_HEX_ESCAPE = /[a-f0-9]/i\n\nexport default function tokenizer (input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, lines, last, content, escape\n  let nextLine, nextOffset, escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let offset = -1\n  let line = 1\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position () {\n    return pos\n  }\n\n  function unclosed (what) {\n    throw input.error('Unclosed ' + what, line, pos - offset)\n  }\n\n  function endOfFile () {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken (opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n    if (\n      code === NEWLINE || code === FEED ||\n      (code === CR && css.charCodeAt(pos + 1) !== NEWLINE)\n    ) {\n      offset = pos\n      line += 1\n    }\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n          if (code === NEWLINE) {\n            offset = next\n            line += 1\n          }\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES:\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, line, pos - offset]\n        break\n\n      case OPEN_PARENTHESES:\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE &&\n          n !== SPACE && n !== NEWLINE && n !== TAB &&\n          n !== FEED && n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1),\n            line, pos - offset,\n            line, next - offset\n          ]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', line, pos - offset]\n          } else {\n            currentToken = ['brackets', content,\n              line, pos - offset,\n              line, next - offset\n            ]\n            pos = next\n          }\n        }\n\n        break\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        quote = code === SINGLE_QUOTE ? '\\'' : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        content = css.slice(pos, next + 1)\n        lines = content.split('\\n')\n        last = lines.length - 1\n\n        if (last > 0) {\n          nextLine = line + last\n          nextOffset = next - lines[last].length\n        } else {\n          nextLine = line\n          nextOffset = offset\n        }\n\n        currentToken = ['string', css.slice(pos, next + 1),\n          line, pos - offset,\n          nextLine, next - nextOffset\n        ]\n\n        offset = nextOffset\n        line = nextLine\n        pos = next\n        break\n\n      case AT:\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1),\n          line, pos - offset,\n          line, next - offset\n        ]\n\n        pos = next\n        break\n\n      case BACKSLASH:\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1),\n          line, pos - offset,\n          line, next - offset\n        ]\n\n        pos = next\n        break\n\n      default:\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          content = css.slice(pos, next + 1)\n          lines = content.split('\\n')\n          last = lines.length - 1\n\n          if (last > 0) {\n            nextLine = line + last\n            nextOffset = next - lines[last].length\n          } else {\n            nextLine = line\n            nextOffset = offset\n          }\n\n          currentToken = ['comment', content,\n            line, pos - offset,\n            nextLine, next - nextOffset\n          ]\n\n          offset = nextOffset\n          line = nextLine\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1),\n            line, pos - offset,\n            line, next - offset\n          ]\n\n          buffer.push(currentToken)\n\n          pos = next\n        }\n\n        break\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back (token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n"]},"metadata":{},"sourceType":"script"}